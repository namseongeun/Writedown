# 주의사항(시험문제 관련)

---

## 데이터 구조(Data Structure)

---

- 컨테이너
  - 시퀀스형(순서가 있는 데이터 구조)
    - 문자열
    - 리스트
    - 튜플
    - 레인지

  - 논시퀀스형(순서가 없는 데이터 구조)
    - 세트
    - 딕셔너리


---

## 메서드(method)

---

- **메서드(method)** : 어떠한 객체가 동사의 형태를 수행하는 것을 말한다.

---

1. 시퀀스형 (순서가 있는 데이터 구조)

   - 문자열 조회/ 탐색 및 검증 메서드

     - s.find(x): x의 첫 번째 위치를 반환. 없으면 -1을 반환

     ```python
     "apple".find("p")	# 반환값: 1
     ```

     - s.index(x): x의 첫 번째 위치를 반환. 없으면 오류 발생
     - s.isalpha(): 알파벳 문자 여부(유니코드 상 Letter)
     - s.isupper(): 대문자 여부
     - s.islower(): 소문자 여부
     - s.istitle(): 타이틀 형식 여부(공백을 기준으로 했을 때, 시작이 대문자인지를 검증)
       - 메서드가 is로 시작하면 Output이 boolean 형태.

   

   - 문자열 관련 검증 메서드
     - isdecimal()
     - isdigit()
     - isnumeric()

   

   - 문자열 변경 메서드
     - s.replace(old, new[,count]): 바꿀 대상 글자를 새로운 글자로 바꿔서 반환
       - count를 지정하면, 해당 개수만큼만 시행
     - s.strip([chars]): 공백이나 특정 문자를 제거
       - 양쪽(strip)/ 왼쪽(lstrip)/ 오른쪽(rstrip) 제거
     - s.split(sep=None, maxsplit = -1):  공백이나 특정 문자를 기준으로 분리
       - sep이 None이거나 지정되지 않으면 연속된 공백문자를 단일한 공백문자로 간주하고, 선행/후행 공백은 빈 문자열에 포함시키지 않는다.
       - maxsplit이 -1인 경우에는 제한이 없다.
     - 'separator'.join([iterable]): 구분자로 iterable을 합침
       - 반복가능한(iterable) 컨테이너 요소들을 separator(구분자)로 합쳐 문자열을 반환
       - iterable에 문자열이 아닌값이 있으면 TypeError 발생
     - s.capitalize(): 가장 첫 번째 글자를 대문자로 변경
     - s.title(): 따옴표 또는 공백 이후를 대문자로 변경
     - s.upper(): 모두 대문자로 변경
     - s.lower(): 모두 소문자로 변경
     - s.swapcase(): 대문자와 소문자를 서로 변경

   

   - 리스트 메서드

     - L.append(x): 리스트 마지막에 항목 x를 추가

     - L.insert(i, x): 리스트 인덱스 i에 항목 x를 삽입

     - L.remove(x): 리스트 가장 왼쪽에 있는 항목 x를 제거. 항목이 존재하지 않을 경우 ValueError

     - L.pop(): 리스트의 가장 오른쪽에 있는 항목을 반환 후 제거

     - L.pop(i): 리스트의 인덱스 i에 있는 항목을 반환 후 제거

     - L.extend(m): 순회형(iterable)m의 모든 항목들의 리스트 끝에 추가(+=와 같은 기능)

     - L.index(x): 리스트에서 x값을 찾아 해당 인덱스를 반환. 없으면 ValueError

     - L.index(x, start, end): 리스트에 있는 항목 중 가장 왼쪽에 있는 항목 x의 인덱스를 반환

     - L.reverse(): 리스트를 거꾸로 정렬

     - L.sort(): 리스트를 정렬(매개변수 이용가능)

       ```python
       a = [100, 10, 1, 5]
       b = [100, 10, 1, 5]
       
       # 1.메서드(list.sort()): 원본 리스트를 정렬(변경)시키고 None를 반환
       print(a.sort())		# output: None	
       
       # 2.함수(sorted(b)): 원본 리스트는 유지하되 함수가 적용된 리스트를 반환
       print(sorted(b))	# output: [1, 5, 10, 100]
       ```

     - L.count(x): 리스트에서 항목 x가 몇 개 존재하는지 갯수를 반환

     - L.clear(): 리스트를 초기화

   

   - 튜플 메서드: 사실상 tuple은 알고리즘 상 직접 만들어서 쓰는 경우가 없다.

   

2. 논시퀀스형 (순서가 없는 데이터 구조)

   - 셋 메서드: 순서 없이 0개 이상의 해시 가능한 객체를 참조하는 자료형(불변 자료형만!)

     ​				   담고 있는 객체를 삽입, 변경, 삭제 가능

     - s.copy(): 셋의 얕은 복사본을 반환
     - s.add(x): 항목 x가 셋에 없다면 추가
     - s.pop(): 셋에서 랜덤하게 항목을 반환하고 해당 항목을 제거. 셋이 비어있을 경우 KeyError
     - s.remove(s): 항목 x를 셋에서 삭제. 항목이 없을 경우 KeyError
     - s.discard(x): 항목 x가 셋에 있는 경우 항목x를 셋에서 삭제
     - s.update(t): 셋 t에 있는 항목 중 셋 s에 없는 항목을 추가
     - s.clear(): 모든 항목 제거
     - s.isdisjoint(t): 셋 s 가 셋 t 의 서로 같은 항목을 하나라도 갖고 있지 않은 경우 True 반환
     - s.issubset(t): 셋 s가 셋t의 하위 셋인경우 True 반환
     - s.issuperset(t): 셋 s가 셋t의 하위 셋인경우 True 반환

   

   - 딕셔너리 메서드: 순서 없이 키:값 쌍으로 이뤄진 객체를 참조하는 자료형
     - d.clear(): 모든 항목을 제거
     - d.copy(): 딕셔너리의 얕은 복사본을 반환
     - d.keys(): 딕셔너리의 모든 키를 담은 뷰를 반환
     - d.values(): 딕셔너리의 모든 값을 담은 뷰를 반환
     - d.items(): 딕셔너리의 모든 키값 쌍을 담은 뷰를 반환
     - d.get(k): 키 k의 값을 반환하는데 키 k가 없는 경우 None을 반환
     - d.get(k, v): 키 k의 값을 반환하는데 키 k가 없는 경우 v를 반환
     - d.pop(k): 키 k의 값을 반환하고 딕셔너리에서 삭제하는데 없는 경우 KeyError.
     - d.pop(k,v): 키 k의 값을 반환하고 딕셔너리에서 삭제하는데 없는 경우 v qksghks.
     - d.update([other]): 딕셔너리 d의 값을 매핑하여 업데이트



---

## 얕은 복사와 깊은 복사

---

- 할당(assignment)

  - 대입 연산자( = )

    ```python
    original_list = [1,2,3]
    copy_list = original_list		# 복사: 이 경우에는 두 변수가 같은 오브젝트를 가짐
    print(original_list, copy_list)
    
    copy_list[0] = "hello"
    print(original_list, copy_list)	 # 둘다 바뀜
    
    
    original_list = [1,2,3]
    copy_list = original_list[:]	# 복사: 이 경우에는 두 변수가 다른 오브젝트를 가짐
    print(original_list, copy_list)
    
    copy_list[0] = "hello"
    print(original_list, copy_list) # copy_list만 바뀌게 됨
    ```

    

- 얕은복사(shallow copy)의 주의사항

  ```python
  a = [1, 2, ["a", "b"]]
  b = a[:]
  print(a,b)
  ```




- 깊은복사(deep copy)

  ```python
  import copy
  a = [1, 2, ["a", "b"]]
  b = copy.deepcopy(a)
  print(a,b)
  
  b[2][0] = 0
  print(a,b)
  ```



---

## 디버깅

---

- 디버깅 
  - 조건 / 반복 / 함수에서 많이 생김
  - braches: 모든 조건이 원하는 대로 동작하는지
  - for loops: 반복문에 진입하는지, 원하는 횟수만큼 실행되는지
  - while loops: for loops와 동일, 종료조건이 제대로 동작하는지
  - function: 함수 호출시, 함수 파라미터, 함수 결과, 데이터 타입



- 디버깅 방법
  - print 함수 활용
    - 특정 함수 결과, 반복/ 조건 결과 등 나워서 생각/ 코드를 bisection으로 나눠서 생각
  - 개발 환경 등에서 제공하는 기능 활용
    - breakpoint, 변수 조회 등
  - Python tutor 활용(단순 파이썬 코드인 경우)
  - 뇌컴파일, 눈 디버깅



- 에러 발생

  - 코드를 작성하다가 에러메세지가 발생하는 경우 
    - 해당 위치를 찾아 메시지를 해결

  - 로직 에러가 발생하는 경우
    - 명시적인 에러 메세지 없이 예상과 다른 결과가 나온경우
      - 정상적으로 동작하였던 코드 이후 작성된 코들르 생각해봄
      - 전체 코드를 살펴봄
      - 휴식을 가져봄
      - 누구가에게 설명해봄
      - ...



- 에러 종류
  - 문법 에러(Syntax Error)
    - 파이썬 프로그램이 실행되지 않음
    - invalid syntax: 유효하지 않은 문법
    - assign to literal: 문자를 읽을 수 없는 오류
    - EOL(End of Line): 문장이 안 끝난 오류
    - EOF(End of File): 파일이 안 끝난 오류
  - 예외(Exception)
    - 실행 도중 예상치 못한 상황을 맞이하면 프로그램 실행을 멈춤
      - 문장이나 표현식이 문법적으로 옳더라도 나는 오류
    - ZeroDivisionError : 0으로 나누고자 할때 발생
    - NameError: namespace 상에 이름이 없는 경우
    - TypeError: 타입 불일치 / argument 누락, 개수 초과, 타입 불일치 ...
    - ValueError: 타입을 올바르나 값이 적절하지 않거나 없는 경우
    - IndexError: 인덱스가 존재하지 않거나 범위를 벗어나는 경우
    - KeyError: 딕셔너리에서 존재하지 않는 Key를 호출하는 경우
    - ModuleNotFoundError 존재하지 않는 모듈을 임포트 하려는 경우
    - ImportError: 모듈은 있으나 존재하지 않는 클래스나 함수를 가져오는 경우
    - KeyboardError: 키보드로 강제로 종료한 경우
    - IndentationError: Indentation이 존재하지 않는 경우
  - 파이썬 내장 예외

---

- 예외처리

  - try문 / except 절 이용하여 예외처리를 할 수 있음

    ```python
    try:
        num = input("숫자입력 : ")
        print(int(num))
    except ValueError:
    	print("숫자가 입력되지 않았습니다.")
    
        
    # 에러메세지 출력    
    try:
        num = input("숫자입력 : ")
        print(int(num))
    except ValueError as ve:
    	print(f"{ve}, 숫자가 입력되지 않았습니다.") 
    ```

  - if / else 문과의 차이

    if / else 문은 오류가 발생하는 경우 함수가 멈추지만,

    try / except 문은 오류가 발생하는 경우에도 함수를 계속 진행되도록 처리할 수  있다.

  - raise문: raise를 통해 예외를 강제로 발생

    ```python
    raise <에러명>, <출력메세지>
    ```

  - assert문: 예외를 강제로 발생시킴

    ```python
    assert <에러명>, <출력메세지>
    ```

    