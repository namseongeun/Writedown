# 컴퓨팅 사고력

## 기초 논리 & 수학

### 이산수학과 연속수학

---

**이산수학**: 논리, 집합 등

**연속수학**: 미분, 적분 등

실제 사용 분야

- 논리: 모든 프로그래밍
- 집합, 논리, 명제, 확률: 기계학습, 인공지능
- 행렬: 영상처리, 그래픽스, 기계학습
- 트리, 그래프: 자료구조, 알고리즘





### 서론 - 프로그래밍과 논리 / 수학

---

**논리**

- **Hard Logic** vs **Soft Logic**
- 일상 생활에서는 Soft Logic이 빠르기 때문에 유용하다.
- 논리적으로 부정확한 표현을 사용하지만 어떤 의미인지 모든 사람이 이미 알고 있다는 가정이 존재
- **프로그래밍은 Hard Logic을 사용**한다.
  - 프로그래밍 언어의 표현들이 모두 논리학에서 나온것
  - 사용되는 수많은 알고리즘들을 이해하기 위해서는 Hard Logic이 필요하다.



- 오해의 근원
  - Soft Logic으로 알고리즘을 이해하려고 하는 것
  - 알고리즘 설명을 보고 또 봐도 이해가 안되는 것은 증명을 안봤기 때문
  - 증명을 봐도 이해가 안되는 것은 직관으로 이해하려고 하기 때문
  - 가끔 직관적으로 이해되는 알고리즘이 있지만 조금만 어려워지면 직관으로 완전한 이해를 얻는 것은 사실상 불가능



- [참고]

  - **명제**

    - **참이나 거짓을 알 수 있는 식이나 문장**
    - p, q, r, ... 로 표현

  - **진리값**

    - **참이나 거짓을 표현**
    - T/F 또는 1/0

  - **연산 (결합)**

    - **부정 NOT**

      - p가 명제일 때 명제의 진릿값이 반대

      - ~p 또는 ㄱp로 표기 (not p 또는 p의 부정으로 읽음)

        | p    | ~p   |
        | ---- | ---- |
        | T    | F    |
        | F    | T    |

        

    - **논리곱 AND**

      - p, q가 명제일 때, **p와 q 모두 참일 때만 참**이 되는 명제

      - **p ^ q (p and q, p 그리고 q)**

        | p    | q    | p^q  |
        | ---- | ---- | ---- |
        | T    | T    | T    |
        | T    | F    | F    |
        | F    | T    | F    |
        | F    | F    | F    |

    - **논리합 OR**

      - p, q가 명제일 때, **p와 q 모두 거짓일 때만 거짓**이 되는 명제

      - **p v q (p or q, p 또는 q)**

        | p    | q    | pvq  |
        | ---- | ---- | ---- |
        | T    | T    | T    |
        | T    | F    | T    |
        | F    | T    | T    |
        | F    | F    | F    |

    - **베타적 논리합 XOR**

      - p, q가 명제일 때, **p와 q 중 하나만 참일 때 참이 되는 명제**

        | p    | q    | p xor q |
        | ---- | ---- | ------- |
        | T    | T    | F       |
        | T    | F    | T       |
        | F    | T    | T       |
        | F    | F    | F       |

        

  - **합성**

    - 연산자 우선 순위 : `NOT` >` AND` = `OR` > `조건명제` = `쌍방조건명제`

    - **항진명제**: 진릿값이 항상 참

    - **모순명제**: 진릿값이 항상 거짓

    - **사건명제**: 항진명제도 모순명제도 아닌 명제

    - **조건명제**

      - p, q가 명제일 때, 명제 p가 조건, q가 결론으로 제시되는 명제

      - p -> q (p이면 q이다.)

        | p    | q    | p -> q |
        | ---- | ---- | ------ |
        | T    | T    | T      |
        | T    | F    | F      |
        | F    | T    | T      |
        | F    | F    | T      |

      - **조건 명제의 역, 이, 대우**

        - **역: q -> p**

        - **이: ~p -> ~q**

        - **대우: ~q -> ~p**

          | p    | q    | ~p   | ~q   | p -> q | q -> p | ~p -> ~q | ~q -> ~p |
          | ---- | ---- | ---- | ---- | ------ | ------ | -------- | -------- |
          | T    | T    | F    | F    | T      | T      | T        | T        |
          | T    | F    | F    | T    | F      | T      | T        | F        |
          | F    | T    | T    | F    | T      | F      | F        | T        |
          | F    | F    | T    | T    | T      | T      | T        | T        |

    - **쌍방조건명제**

      - **p, q가 명제일 때, 명제 p와 q가 모두 조건이면서 결론인 명제**

      - **p <-> q (p면 q고, q면 p다.)**

        | p    | q    | p <-> q |
        | ---- | ---- | ------- |
        | T    | T    | T       |
        | T    | F    | F       |
        | F    | T    | F       |
        | F    | F    | T       |



- 논리 연습
  - 문제1: 다음은 명제식 형태로 쓰고 참인지 거짓인지 판단하시오
    1. 만약 0이 홀수라면 미국에서 2080년 월드컵이 열린다.
       - 0이 홀수가 아니니까 거짓. 즉 2080년 월드컵에 열리는 것의 진위여부와 관계없이 참.
    2. 만약 19893827938274839가 Prime Number라면, 2는 짝수이다.
       - 2가 짝수인 것이 참 그러므로 전자의 진위여부와 관계없이 참.
  - 문제2: p와 q가 명제이고 p ->q가 거짓이라고 하자 다음 명제식의 참 거짓은 어떻게 되는가?
    1. ~p -> q
       - p는 참 q는 거짓, ~p는 거짓 즉 전체 명제는 참
    2. p v q
       - p는 참 q는 거짓 둘 중 하나만 참이면 참이므로 전체 명제는 참 
    3. q -> p
       - q는 거짓이므로 뒤의 여부와 관계 없이 전체 명제는 참



- **증명**
  - 증명은 **정확한 명제식으로 표현**할 수 있는 것이라야 함 
  - 보통은 정확한 명제식까지 쓰지는 않으나 근본적으로는 명제식으로 바꿀 수 있음
  - 증명에 대한 수많은 오해가 p->q 를 p<->q와 혼동하는 것에서 일어남

​		

- **수학적 귀납법과 증명의 수준**
  - **수학적 귀납법의 기본형**: P(1)이 참이고 P(n) -> P(n+1)이 참이면 P(n)은 모든 자연수 n에 대해서 참이다.
  - **수학적 귀납법의 강한 형태**: P(1)이 참이고, P(1)^P(2)^ ... ^P(n) -> P(n+1)이 참이면 P(n)은 모든 자연수 n에 대해서 참이다.
  - 상세한 증명을 하려면 단순히 '답이 맞는 것이 당연하다'라고 말하는 것으로는 충분하지 않다.
    - 증명이 가능한 명제를 만들어야 함
    - 이 경우 증명이 가능한 명제는 다음과 같다.
      - sum(x)가 리턴하는 값은 `1 + 2 + 3 + ... + x`의 값과 항상 같다
    - 이제 수학적 귀납법을 적용할 수 있다.
    - P(1)이 참이다. : sum(1)이 리턴하는 것은 1이다 를 증명하면 된다.



### 논리와 증명

---

- 문제1: 다음 명제들이 항진명제라는 것을 진리표를 이용해서 보이시오

  1. ~(~p ^ q) v q

     | p    | q    | ~p   | (~p ^ q) | ~(~p ^ q) | ~(~p ^ q) v q |
     | ---- | ---- | ---- | -------- | --------- | ------------- |
     | T    | T    | F    | F        | T         | T             |
     | T    | F    | F    | F        | T         | T             |
     | F    | T    | T    | T        | F         | T             |
     | F    | F    | T    | F        | T         | T             |

- 문제2: 다음 명제들이 모순명제라는 것을 진리표를 이용해서 보이시오

  1. (~p v q) ^ (p ^ ~q)

     | p    | q    | ~p   | ~q   | (~p v q) | (p ^ ~q) | (~p v q) ^ (p ^ ~q) |
     | ---- | ---- | ---- | ---- | -------- | -------- | ------------------- |
     | T    | T    | F    | F    | T        | F        | F                   |
     | T    | F    | F    | T    | F        | T        | F                   |
     | F    | T    | T    | F    | T        | F        | F                   |
     | F    | F    | T    | T    | T        | F        | F                   |

     

### 수와 표현

---

- **약간의 설명**
  - 컴퓨터는 0과 1을 표현할 수 있는 비트들을 모아 수를 표현
  - k개의 비트를 사용하면 0부터 2^k - 1 까지 표현 가능
  - 10진수로 k 자리를 쓰면 0부터 10^k - 1까지 표현이 가능한 것과 완전히 동일한 과정
  - 어떤 값 n을 표현하기 위해서는 몇 개의 비트가 필요할까?
    - 2^k - 1 >= n이 성립해야 한다. 즉 2^k >= n + 1
    - 같은 의미로 k >= log(n + 1)  약 log(n) 비트가 필요하다
    - 위의 식을 잘 보면 logn이란,
      - 2의 몇 승이 n이 되느냐의 답
      - n을 표현하는데 몇 비트가 필요한가의 답
      - 1로 시작해서 계속 두 배를 할 때 몇 번 하면 n이 되느냐의 답
      - n을 2로 계속 나눌 때 몇 번 나누면 거의 1이 되느냐에 대한 답
    - x = logn일 때 x와 n을 비교하면 x가 더 작고 n이 커질수록 엄청나게 달라진다.
    - 100자리로 표현할 수 있는 10진수 값은 읽을 수도 없을 정도로 큰 값



- 문제들

  - 문제1: 2진수 표현에서 logn 비트로 표현할 수 있는 숫자 범위는?

    - 2^log^n = n^log^2

      ​				= n^1

      ​				= n

  - 문제3: n이 충분히 큰 값일 때 다음 중 어느 값이 더 큰가?

    1. `2n` vs `n^2`
       - n^2
    2. `2^(n*logn) ` vs `n!`
       - 2^(n*logn)



### 집합과 조합론

---

- 집합과 조합론
  - 두 집합 A와 B에 대해 A가 B의 부분집합임을 증명한다는 것은 A의 임의의 원소가 B에 포함됨을 보이는 것과 같다.
  - 예를 들어 모든 4의 배수는 2의 배수라는 것을 증명하려면 4k = 2(2k)임을 보이면 된다.
  - 조합론은 경우의 수를 따지는 문제들을 말한다.
  - 조합은 개수는 C를 이용하여 표현하기도 하지만 괄호표현을 더 많이 쓴다.



- 문제들
  - 문제1: nCk + nCk-1 = n+1Ck 임을 증명하여라



### 기초 수식

---

- 문제들: 다음 재귀식들을 Big O 표기법으로 나타내라

  - 문제1: T(n) = T(n-1) + 1 , T(0)  = 1

    ```
    T(n) = T(n-1) + 1 (단, T(0) =1)
    	 = T(n-2) + 1 + 1
    	 만약 2를 k라고 하면,
    	 = T(n-k) + k
    	 n = k인 경우
    	 = T(0) + n
    	 = n + 1
    	
    그러므로 시간복잡도는 O(n)
    ```

  - 문제2: T(n) = T(n-1) + n , T(0)  = 1

    ```
    T(n) = T(n-1) + n (단, T(0) =1)
    	 = T(n-2) + n + n
    	 만약 2를 k라고 하면,
    	 = T(n-k) + kn
    	 n = k인 경우
    	 = T(0) + n^2
    	 = n^2 + 1
    	
    그러므로 시간복잡도는 O(n^2)	
    ```

  - 문제3: T(n) = T(n-1) + logn , T(0)  = 1

    ```
    T(n) = T(n-1) + logn (단, T(0) =1)
         = T(n-2) + logn + logn
         만약 2를 k라고 하면,
    	 = T(n-k) + klogn
    	 n = k인 경우
    	 = T(0) + nlogn
    	 = nlogn + 1
    	 
    그러므로 시간복잡도는 O(nlogn)	 
    ```

    

### 재귀

---

**피보나치**

- ```python
  def fibo(n):
  	if n == 1 or n ==2:
          return 1
      return fibo(n-1) + fibo(n-2)
  ```

- 



**머지소트**

### 동적 프로그래밍

---

- 설명
  - 간단하게 설명하면 **재귀 함수에서 동일한 입력의 함수 호출이 반복적으로 일어날 때 그 결과 값을 저장해두고 불러쓰는 것**이다. (Memoization)
  - 최초 입력에서 파생되는 **모든 가능한 입력에 대한 답을 모두 저장할 수 있는 메모리가 있어야한다**.
  - 단순히 재귀에서 저장된 값을 찾아보는 것으로도 가능하지만 결과 값을 순서를 정해서 계산할 수도 있다.



- 문제들: 다음 문제들을 푸는 동적 프로그래밍 알고리즘을 수도코드로 작성하고 정확성 증명 및 시간 복잡도 계산을 수행하라

  - 문제1: Memoization 피보나치 수열

    - F(n) = F(n-1) + F(n-2), F(1) = F(2) = 1

    - (힌트) 계산되는 값이 n 가지 밖에 없으므로 이 값들을 저장할 수 있는 배열을 만들어 두고 재귀 호출에 들어가기 전에 값이 있는지 확인하는 방법

      ```
      Fibonacci(n)
      {
      	if n == 0 or n == 1
          	then return n
          	
         	if memoization[n] != null
         		then return memoization[n]
         		
         	memoization[n] = Fibonacci(n-1) + Fibonacci(n-2)
         	
         	return memoization[n]
      }
      ```

  - 문제2: Dynamic Programming 피보나치 수열

    - F(n) = F(n-1) + F(n-2)

    - (힌트) 작은 값부터 순서대로 계산한다.

      ```
      Fibonacci(n)
      {
      	F[0] <- 0
      	F[1] <- 1
      	
      	for i <-2, i <= n, i <- i+1
      		F[i] = F[i-1] + F[i-2]
      		
      	return F[n]
      }
      ```

      



- 해법들

  1. **하향식(memoization 피보나치)**

     ```python
     def fibo(n):
         if n < 2:
             return n
         if lst[n]:
             return lst[n]
         lst[n] = fibo(n-1) + fibo(n-2)
         return lst[n]
         
         
     n = 6
     lst = [0] * (n-1)
     pritn(fibo(n))
     ```


  2. **상향식(DP 피보나치)**

     ```python
     def fibo(n):
         lst = [1,1]
         if n < 2:
             return lst[n]
         while len(lst) < n:
             lst.append(lst[-1] + lst[-2])
         return lst[-1]
     ```

     




### 시간 복잡도 big O 의 특징

1. **복잡도의 점근적 상한**을 나타냄
2. **복잡도의 다항식 최고차항만 계수 없이 취하면 된다.**
   - 상수 항 무시
     - O(2N), O(N/2) -> O(N)
   - 영향력 없는 항은 무시
     - O(n^2 + 2n + 1) -> O(n^2)
