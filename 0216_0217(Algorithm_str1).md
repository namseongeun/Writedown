# Algorithm Str_1

---

### 문자열 (String)

---

**문자의 표현**

- **컴퓨터에서의 문자표현** 
  - 글자 A를 메모리에 저장하는 방법에 대해 생각해보자
  - 메모리는 숫자만을 저장할 수 있기 때문에 A라는 글자의 모양 그대로 비트맵으로 저장하는 방법을 사용하지 않는 한(이 방법은 메모리 낭비가 심하다) 각 문자에 대해서 대응되는 숫자를 정해놓고 이것을 메모리에 저장하는 방법이 사용될 것이다.
  - 영어가 대소문자 합쳐서 52이므로 6비트면 모두 표현할 수 있다.
  - 이를 코드쳬계라고 한다.
  - 그런데 네트워크가 발전되기 전 미국의 각 지역 별로 코드체계를 정해놓고 사용했지만 네트워크가 발전하면서 서로 간 정보를 주고 받을 때 정보를 달리 해석한다는 문제가 생겼다.
  - 그래서 혼동을 피하기 위한 표준안을 만들기로 한다.



- **ASCII 코드** (American Standard Code for information Intercharnge)
  - 위에서 언급한 이유로 1967년, 미국에서 ASCII라는 문자 인코딩 표준이 제정되었다.
  - ASCII는 7bit 인코딩으로 128문자를 표현하며 33개의 출력 불가능한 제어문자들과 공백을 비롯한 95개의 출력 가능한 문자들로 이루어져 있다.
  - 출력 가능한 아스키 문자: 32~126



- **확장 아스키**
  - 표준 문자 이외의 악센트 문자, 도형문자, 특수문자, 특수 기호 등 부가적인 문자를 128개 추가할 수 있게 하는 부호
    - 표준 아스키에 1B 내의 8bit를 모두 사용함으로써 추가적인 문자를 표현할 수 있다.
    - 컴퓨터 생산자와 소프트웨어 개발자가 여러 가지 다양한 문자에 할당할 수 있도록 하고 있다. 할당된 확장 부호는 표준 아스키와 같이 서로 다른 프로그램이나 컴퓨터 사이에 교환되지 못한다.
    - 표준 아스키는 마이크로 컴퓨터 하드웨어 및 소프트웨어 사이에서 세계적으로 통용되는 데 비해, 확장 아스키는 프로그램이나 컴퓨터 또는 프린터가 그것을 해독할 수 있도록 설계되어 있어야만 올바로 해독될 수 있다.



- **아스키의 한계**
  - 컴퓨터가 발전하면서 미국 뿐 아니라 각 나라에서도 컴퓨터가 발전했으며 각 국가들은 자국의 문자를  표현하기 위하여 코드 체계를 만들어서 사용하게 되었다.
  - 인터넷이 전 세계로 발전하면서 ASCII를 만들었을 때의 문제와 같은 문제가 국가간에 정보를 주고 받을 때 발생했다.
  - 자국의 코드체계를 타 국가가 가지고 있지 않으면 정보를 잘못 해석할 수 밖에 없었다.
  - 다국어 처리를 위한 표준이 필요해졌다.



- **유니코드**
  - 다국어 처리를 위한 표준안
  - 유니코드는 다시 Character Set으로 분류된다.
    - UCS-2 (Universal Charater Set 2)
    - UCS-4 (Universal Charater Set 4)
    - 유니코드를 저장하는 변수의 크기를 정의
    - 그러나 바이트 순서에 대해서 표준화하지 못했음
    - 다시 말해 파일을 인식 시 이 파일이 UCS-2, UCS-4인지 인식하고 각 경우를 구분해서 모두 다르게 구현해야 하는 문제가 발생
    - 유니코드의 적당한 외부 인코딩이 필요하게 되었다

  - **유니코드 인코딩** (UTF: Unicode Transformation Format)
    - UTF-8 (in Web)
      - MIN: 8bit, MAX: 32bit
    - UTF-16 (in Windows, java)
      - MIN: 16bit, MAX: 32bit
    - UTF-32 (in Unix)
      - MIN: 32bit, MAX: 32bit
  - **Python 인코딩**
    - 2.x 버전 - ASCII : `#-*- coding: utf-8 -*-`
    - 3.x 버전 - 유니코드 : 생략 가능
    - 다른 인코딩 방식으로 처리 시 첫 줄에 작성하는 위 항목에 원하는 인코딩 방식을 지정



- **문자열의 분류**
  - **문자열**
    - fixed length
    - variable length
      - length controlled : java 언어에서의 문자열
      - delimited : c 언어에서의 문자열



- **Python에서의 문자열 처리**
  - char 타입 없음
  - 텍스트 데이터의 취급방법이 통일되어 있음
  - 문자열 기호
    - `'', "", ''', """`
    - 연결: `+`
    - 반복: `문자열 * 수`
  - 문자열은 시퀀스 자료형, 시퀀스 자료형에서 사용할 수 있는 인덱싱, 슬라이싱 연산들을 사용할 수 있음
  - 문자열 클래스에서 제공되는 메소드들 참고
  - 문자열은 요소값을 변경할수 없다.



- 참고

  - 다음 두 코드의 차이 이해하기

    ```python
    s1 = list(input())
    s2 = input()
    ```

    - 첫번째는 문자열의 문자들을 리스트로 만들어서 반환하고 두번째는 문자열을 반환한다.

    ```python
    s1 = list(input())
    s2 = input()
    s1[0] = 'd'
    s2[0] = 'd'
    ```

    - 첫 번째는 리스트여서 첫번째 원소가 d로 변경되지만 두번째는 문자열이어서 변경이 불가능하다.

  - strlen() 함수 만들어 보기

    - def strlen(a): # "\0" 을 만나면 그를 제외한 글자수를 리턴

    ```python
    def mystrlen(s):
        i = 0
        while s[i] != '\0':
            i += 1
        return i
        
    a = ['a', 'b', 'c', '\0']
    print(mystrlen(a))
    ```

  - 출력

    ```python
    print("a", end = " ") # "a"를 출력하고 다음 문자는 공백 뒤에
    print("\n", end = " ") # 줄바꿈
    print() # 줄바꿈
    print("b")
    ```



- **문자열 뒤집기**

  - 자기 문자열에서 뒤집는 방법이 있고 새로운 빈문자열을 만들어 소스의 뒤에서부터 읽어 타겟에 쓰는 방법이 있다.

  - 자기 문자열을 이용할 경우는 swap을 위한 임시 변수가 필요하며 반복 수행을 문자열 길이의 반만을 수행해야 한다.

  - Python 은 reverse 함수 혹은 slice notation을 이용하여 구현하면 된다.

    ```python
    s = s[::-1]
    s = s.reverse()		# string에서는 동작안함
    ```

- **문자열 비교**

  - `==` 연산자를 사용

    ```python
    s1 = 'abc'
    s2 = 'abc'
    s3 = 'def' 
    s4 = s1
    s5 = s1[:2] + 'c'
    # 비교해보기
    ```

  - 이 부분 다시보기로 확인 

  - 등호로 문자열을 비교하면 사전에서 더 빠른지 확인 가능



- **문자열 숫자를 정수로 변환하기**

  - 파이썬에서는 숫자와 문자변환 함수를 제공한다.

  - int()와 같은 atoi() 함수 만들기

    ```python
    def atoi(s):
        i = 0
        for x in s:
            i = i*10 + ord(x)-ord('0')
        return i
    
    a = '123'
    print(atoi(a))
    ```

    

---

### 패턴매칭

---

- **패턴 매칭에 사용되는 알고리즘들**
  - 고지식한 패턴 검색 알고리즘 (인덱스 연산)
  - 카프-라빈 알고리즘
  - KMP 알고리즘
  - 보이어-무어 알고리즘



- **고지식한 알고리즘(Brute Force)**

  - 본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 일일이 비교하는 방식으로 동작

    ```python
    p = 'is'				# 찾을 패턴
    t = "This is a book~!"	# 전체 텍스트
    M = len(p)				# 찾을 패턴의 길이
    N = len(t)				# 전체 텍스트의 길이
    
    def BruteFroce(p,t):
        i = 0				# t의 인덱스
        j = 0				# p의 인덱스
        while j < M and i < N:
            if t[i] != p[j]:
                i = i-j
                j = -1
            i = i + 1
            j = j + 1
        if j == M: 			# 검색 성공
            return i - M
        else:				# 검색 실패
            return -1
    ```

  - 고지식한 패턴 검색 알고리즘의 시간 복잡도

    - 최악의 경우 시간 복잡도는 텍스트의 모든 위치에서 패턴을 비교해야 하므로 O(MN)이 된다.
    - 예에서는 최악의 경우 약 10,000 * 80 = 800,000번의 비교가 일어난다.



- **KMP 알고리즘**

  - 불일치가 발생한 텍스트 스트링의 앞 부분에 어떤 문자가 있는지를 미리 알고 있으므로, 불일치가 발생한 앞 부분에 대해서 다시 비교하지 않고 매칭을 수행

  - 패턴을 전처리하여 배열 next[M]을 구해서 잘못된 시작을 최소화함

    - next[M]: 불일치가 발생했을 경우 이동할 다음 위치

  - 시간 복잡도: O(M+N)

  - 아이디어 설명 

    - 텍스트에서 abcdabc까지는 매치되고, e에서 실패한 상황 패턴의 맨 앞의 abc와 실패 직전의 abc는 동일함을 이용할 수 있다.
    - 실패한 텍스트 문자와 P[4]를 비교한다.
    - 매칭이 실패했을 때 돌아갈 곳을 계산한다.
    - 패턴의 각 위치에 대해 매칭에 실패 했을 때 돌아갈 곳을 준비해 둔다.

    ```python
    def kmp(t,p):
        N = len(t)
        M = len(p)
        lps = [0] * (M+1)	# 배열
        
        j = 0		# 일치한 개수 == 비교할 패턴 위치		
        lps[0] = -1
        
        # preprocessing
        for i in range(1, M):
            lps[i] = j			# p[i] 이전에 일치한 개수
            if p[i] == p[j]:
                j += 1
            else: 
        		j = 0
                            
    	lps[M] = j            
        # search
        i = 0
        j = 0
        while i < N and j <= M:
            if j == -1 or t[i] == p[j]:		# 첫글자가 불일치 했거나 일치하면
                i += 1
                j += 1
            else:							# 불일치
                j = lps[j]
            if j == M:						# 패턴을 찾을 경우
                print(i-M, end = '')		# 패턴의 인덱스 출력
                j = lps[j]
    ```

    



- **보이어-무어 알고리즘**
  - 문자열 패턴의 오른쪽에서 왼쪽으로 비교
  - 대부분의 상용 소프트웨어에서 채택하고 있는 알고리즘
  - 보이어-무어 알고리즘은 패턴에 오른쪽 끝에 있는 문자가 불일치하고 이문자가 패턴 내에 존재하지 않는 경우, 이동거리는 무려 패턴의 길이만큼이 된다.
  - 오른쪽에서 끝에 있는 문자가 불일치 하고 이 문자가 패턴내에 존재할 경우에 패턴에서 일치하는 문자를 찾아서 그만큼 점프한다.
  - 예시
    - "rithm" 문자열의 skip 배열
      - **m** : 0  / **h** : 1 /  **t** : 2 / **i** : 3 / **r** : 4 / **다른 모든 문자** : 5
  - 만약 패턴 문자열에 같은 문자가 2개 이상이 연달아 포함되어 있다면, 기본적으로 뒤에 나오는 문자열을 기준으로 한다.
  - 특징
    - 텍스트를 다 보지 않는다.
    - 최악의 경우 수행시간은 O(mn)
    - 입력에 따라 다르지만 일반적으로 O(n)보다 시간이 덜 든다.



- **문자열 매칭 알고리즘 수행시간 비교**
  - 찾고자 하는 문자열 패턴의 길이를 m, 총 문자열 길이를 n이라 할 때,
  - 고지식한 패턴 검색 알고리즘: O(mn)
  - 카프-라빈 알고리즘: O(n)
  - KMP 알고리즘: O(n)



---

### 문자열 암호화 (참고)

---

- 시저암호 (Caesar cipher)
  - 줄리어스 시저가 사용했다고 하는 암호
  - 시저 암호에서는 평문에서 사용되고 있는 알파벳을 일정한 문자수만큼 [평행이동] 시킴으로서 암호화를 행한다.



- 단일 치환 암호의 복호화
  - 복호화 하기 위해서는 모든 키의 조합(key space)가 필요하다.
  - 단일 치환암호의 키의 총수는 26!
  - 1초에 10억 개의 키를 적용하는 속도로 조사한다고 해도 모든 키를 조사하는데 120억년 이상의 시간이 걸린다.



- bit 열의 암호화
  - 배타적 논리합 (exclusive-or) 연산 사용
  - XOR 연산
    - x 와 y 가 같으면 0,  다르면 1을 반환한다.



---

### 문자열 압축 (참고)

---

- 다음과 같은 문자열이 있다. 저장소의 크기를 줄이며 정화한 정보를 저장하는 방법은?
  - ABBBBBBBA



- **Run-length encoding 알고리즘**

  - 같은 값이 몇 번 반복되는가를 나타냄으로써 압축
  - 이 방법은 임지 파일 포맷 중 BMP 파일 포맷의 압축 방법이다.
  - A1B8A1
  - 단점: 교차되는 문자열이 나오면 오히려 두 배로 길어진다.

- 예시 - 9386. 연속된 1의 개수

  ```python
  T = int(input())
  for tc in range(1, T+1):
  	N = int(input())
      arr = list(map(int, input()))
  
      cnts = []
      i = 0
      cnt = 0
      while i < N:
          if arr[i] == 0:
              i += 1
              cnt = 0
          else:
              i += 1
              cnt += 1
              if cnt not in cnts:
                  cnts.append(cnt)
  
      result = max(cnts)    
      print(f"#{tc} {result}")
  ```

  ```python
  T = int(input())
  for tc in range(1, T+1):
      N = int(input())
      arr = list(map(int, input()))
      
      cnt = 0
      max_cnt = 0
      for i in range(len(arr)):
          if arr[i] == 1:
              cnt += 1
              max_cnt = cnt
          else:
              if max_cnt < cnt:
                  max_cnt = cnt
              cnt = 0
  	print(f"#{tc} {max_cnt}") 
  ```