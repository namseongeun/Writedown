# Start

## sw 문제해결

**SW 문제 해결 역량이란 무엇인가?**

- 프로그램을 하기 위한 많은 제약 조건과 요구사항을 이해하고 최선의 방법을 찾아내는 능력
- 프로그래머가 사용하는 언어나 라이브러리, 자료구조, 알고리즘에 대한 지식을 적재적소에 퍼즐을 배치하듯 이들을 연결하여 큰 그림을 만드는 능력이라 할 수 있다.
- 문제 해결 역량은 추상적인 기술이다.
  - 프로그래밍 언어, 알고리즘처럼 명확하게 정의된 실체가 없다.
  - 무작정 알고리즘을 암기하고 문제를 풀어본다고 향상되지 않는다.
- 문제 해결 역량을 향상시키기 위해서 훈련이 필요하다.



**문제 해결 능력을 훈련하기 위해서는**

- 일부 새로운 언어, 프레임워크, 개발 방법론만을 배워나가는 것만으로 충분하지 않다.
- 이들을 조합해 나가는 방법을 배워야 한다.
- 상황을 인위적으로 만들어 훈련해야 한다.



**문제 해결 과정**

1. 문제를 읽고 이해한다.
2. 문제를 익숙한 용어로 재정의한다.
3. 어떻게 해결할지 계획을 세운다.
4. 계획을 검증한다.
5. 프로그램으로 구현한다.
6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.



## 복잡도 분석

**알고리즘**

- 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법
- 주로 컴퓨터용어로 쓰이며 컴퓨터가 어떤일을 수행하기 위한 단계적 방법을 말한다.
- 간단하게 다시 말하면 어떠한 문제를 해결하기 위한 절차라고 볼 수 있다.



- **알고리즘의 효율**
  - 공간적 효율성과 시간적 효율성
    - 공간적 효율성은 연산량 대비 얼마나 적은 메모리 공간을 필요로 하는가를 말한다.
    - 시간적 효율성은 연산량 대비 얼마나 적은 시간을 필요로 하는가를 말한다.
    - 효율성을 뒤집어 표현하면 복잡도이다. 복잡도가 높을수록 효율성은 저하된다.
  - **시간적 복잡도 분석**
    - 하드웨어 환경에 따라 처리시간이 달라진다.
      - 부동소수 처리 프로세서 존재유무, 나눗셈 가속기능 유무
      - 입출력 장비의 성능, 공유여부
    - 소프트웨어 환경에 따라 처리시간이 달라진다.
      - 프로그램 언어의 종류
      - 운영체제, 컴파일러의 종류
    - 이러한 환경적 차이로 인해 분석이 어렵다.
  - **복잡도의 점근적 표기**
    - 시간 또는 공간 복잡도는 입력 크기에 대한 함수로 표기하는데 이 함수는 주로 여러개의 항을 가지는 다항식이다.
    - 이를 단순한 함수로 표현하기 위해 점근적 표기를 사용한다.
    - 입력 크기 n이 무한대로 커질때의 복잡도를 간단히 표현하기 위해 사용하는 표기법이다.



- **Big O 표기**
  - O표기는 복잡도의 점근적 상한을 나타낸다.
  - 복잡도가 f(n) = `2*n^2 - 7*n + 4`라면 f(n)의 O표기는 O(n^2)이다. 
  - 단순화된 함수 n^2의 임의의 상수 c를 곱한 c*n^2이 n이 증가함에 따라 f(n)의 상한이 된다.
  - 단순히 '실행시간이 n^2에 비례'하는 알고리즘이라고도 한다.



- **Big  Ω 표기**
  - Ω표기는 복잡도의 점근적 하한을 나타낸다.
  - 복잡도가 f(n) = `2*n^2 - 7*n + 4`라면 f(n)의 Ω표기는 Ω(n^2)이다. 
  - O표기 때와 마찬가지로 Ω 표기도 복잡도 다항식의 최고차항만 계수 없이 취하면 된다.
  - 최소한 이만큼의 시간은 걸리다는 표현이다.



- **Big  Θ 표기**
  - O표기와 Ω표기가 같은 경우에만 사용한다.
  - f(n)은 n이 증가함에 따라 n^2과 동일한 증가율을 가진다는 의미이다.



- **왜 효율적인 알고리즘이 필요한가**
  - 10억 개의 숫자를 정렬하는데 PC에서 O(n^2)알고리즘은 300여 년이 걸리는 반명에 O(lnogn) 알고리즘은 5분만에 정렬한다.
  - 효율적인 알고리즘은 슈퍼컴퓨터보다 더 큰 가치가 있다.
  - 값 비싼 H/W의 기술 개발보다 효율적인 알고리즘 개발이 훨씬 더 경제적이다.



## 표준 입출력 방법

**Python3 표준입출력**

- **입력**

  - **Raw 값의 입력: input()**
    - 받은 입력값을 문자열로 취급
  - **Evaluated된 값 입력: eval(input())**
    - 받은 입력값을 펴악된 데이터 형으로 취급

- **출력**

  - **print()**
    - 표준 출력함수 출려값의 마지막에 개행 문자 포함
  - **print('text', end='')**
    - 출력 시 마지막에 개행문자 제외할 시
  - **print(%d %number)**
    - Formatting 된 출력

- **파일의 내용을 표준입력으로 읽어오기**

  - **import sys**

  - **sys.stdin = open('a.txt', 'r')**

    ```python
    import sys
    sys.stdin = open("input.txt", "r")
    sys.stdout = open("ouput.txt", "w")
    
    text = input()
    print(text)
    ```

    

## 비트연산

**비트연산**

- **비트연산자**

  | 연산자 | 연산자의 기능                                      |
  | ------ | -------------------------------------------------- |
  | **&**  | 비트 단위로 AND 연산을 한다.                       |
  | **\|** | 비트 단위로 OR 연산을 한다.                        |
  | **^**  | 비트 단위로 XOR 연산을 한다.                       |
  | **~**  | 단항 연산자로서 피연산자의 모든 비트를 반전시킨다. |
  | **<<** | 피연산자의 비트 열을 왼쪽으로 이동시킨다.          |
  | >>     | 피연산자의 비트 열을 오른쪽으로 이동시킨다.        |

  - **& 활용**
    - 비트검사
    - 비트 클리어: 특정 비트를 0으로 만들고자 할 때 (바꾸고 싶은 비트 자리만 0으로)
  - **| 활용**
    - 비트 셋: 특정 비트를 1로 만들고자 할 때 (바꾸고 싶은 비트 자리만 1로)
  - **^ 활용**
    - 특정비트가 같은지 검사
    - 비트 토글
  - **~ 활용**
    - 전부 값을 뒤집고 싶은 경우 사용
  - **<< 활용**
    - AND 또는 OR 연산과 조합할 때 바꾸고 싶은 비트 자리만 0 또는 1인 수를 만드는데 사용



- **비트연산자의 활용**
  - **1<<n**
    - **2^n의 값**을 갖는다.
    - 원소가 n개일 경우의 모든 부분집합의 수를 의미한다.
    - Power set(모든 부분집합)
      - 공집합과 자기 자신을 포함한 모든 부분집합
      - 각 원소가 포함되거나 포함되지 않는 2가지 경우의 수를 계산하면 모든 부분집합의 수가 계산된다.
  - **i&(1<<j)**
    - 계산 결과는 i의 j번째 비트가 1인지 아닌지를 의미한다.



- 비트연산 예제1

  ```python
  def Bbit_pritn(i):
      ouput = ""
      for j in range(7,-1, -1):
          output += "1" if i & (1 << j) else "0"
      print(output)
      
  for i in range(-5, 6)   :
      print("%3d = " %i, end = '')
      Bbit_print(i)
  ```

- 비트연산 예제2

  ```python
  def Bbit_print(i):
      output = ""
      for j in range(7, -1, -1):
          output += "1" if i & (1 << j) else "0"
      print(output, end = " ")
      
  a = 0x10
  x = 0x01020304
  print("%d = " % a, end = "")
  Bbit_print(a)
  print()
  print("0%X = " % x, end = "")
  for i in range(0,4):
      y = (x >> i * 8) & 0xff
      print()
      Bbit_print(y)
  ```



- **엔디안(Endianness)**

  - 컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법을 의미하며 HW 아카텍처마다 다르다.

  - 주의: 속도 향상을 위해 바이트 단위와 워드 단위를 변환하여 연산할 때 올바로 이해하지 않으면 오류를 발생시킬 수 있다.

  - **빅엔디안(Big endian)**

    - 보통 큰 단위가 앞에 나옴. 네트워크.

  - **리틀엔디안(Little endian)**

    - 작은 단위가  앞에 나옴. 대다수의 데스크탑 컴퓨터.

  - 엔디안 확인 코드

    ```python
    import sys
    
    print(sys.byteorder)
    ```

    

- 비트연산 예제 3

  ```python
  def ce(n): # change endian
      p = []
      for i in range(0, 4):
          p.append((n >> (24 - i * 8)) & 0xff)
      return p
  ```

  ```python
  x = 0x01020304
  p = []
  for i in range(0, 4):
      p.append((x >> (i*8)) & 0xff)
      
  print("x = %d%d%d%d" % (p[0, p[1], p[2], p[3]))
  p = ce(x)
  print("x = %d%d%d%d" % (p[0, p[1], p[2], p[3]))
  ```



- 비트연산 예제4

  ```python
  def ce1(n):
      return(n <, 24 & 0xff000000) | 
  		  (n << 8 & 0xff0000) | 
            (n >> 8 & 0xff00) |
            (n >> 24 & 0xff)
  ```

  

## 진수

- **2진수, 8진수, 10진수, 16진수 ...**

- 10진수를 타진수로 변환하기

  - 원하는 타진법의 수로 나눈 뒤 나머지를 거꾸로 읽는다.

- 타진수를 10진수로 변환하기

- 2진수, 8진수, 16진수간 변환

  |            | 2진법        | 8진법        | 16진법       |
  | ---------- | ------------ | ------------ | ------------ |
  | **2진법**  |              | 3자리씩 묶음 | 4자리씩 묶음 |
  | **8진법**  | 3자리씩 나열 |              |              |
  | **16진법** | 4자리씩 나열 |              |              |

  

- **컴퓨터에서의 음의 정수 표현 방법**

  - **1의 보수**
    - **부호와 절대값으로 표현된 값을 부호 비트를 제외한 나머지 비트들을 0은 1로, 1은 0으로 변환한다.**
    - **부호와 절대값 표현**
      - -6: 1000000000000110
    - **1의 보수 표현**
      - -6: 1111111111111001
  - **2의 보수**: **1의 보수방법으로 표현된 값의 최하위 비트에 1을 더한다.**
    - **2의 보수 표현**
      - -6: 1111111111111010



## 실수 

**실수의 표현**

- 소수점 이하 4자리를 10진수로 나타내보면

  | 2진수  | 10진수 |
  | ------ | ------ |
  | 0.0000 | 0      |
  | 0.0001 | 0.0625 |
  | 0.0010 | 0.125  |
  | 0.0011 | 0.1875 |
  | 0.0100 | 0.25   |
  | 0.0101 | 0.3125 |
  | 0.0110 | 0.375  |
  | 0.0111 | 0.4375 |
  | 0.1000 | 0.5    |
  | 0.1001 | 0.5625 |
  | 0.1010 | 0.625  |
  | 0.1011 | 0.6875 |
  | 0.1100 | 0.75   |
  | 0.1101 | 0.8125 |
  | 0.1110 | 0.875  |
  | 0.1111 | 0.9375 |



- **컴퓨터는 실수를 표현하기 위해 부동 소수점(floating-point)표기법을 사용**한다.

- **부동 소수점 표기방법은 소수점의 위치를 고정시켜 표현하는 방식이다.**

  - 소수점의 위치를 왼쪽의 가장 유효한 숫자 다음으로 고정시키고 밑수의 지수승으로 표현

    ```
    1001.0011  => 1.0010011 * 2^3
    ```



- **실수를 저장하기 위한 형식**

  - **단정도 실수(32비트)**

    | 부호 1비트 | 지수 8비트 | 가수 23비트 |
    | ---------- | ---------- | ----------- |

  - **배정도 실수(64비트)**

    | 부호 1비트 | 지수 11비트 | 가수 52비트 |
    | ---------- | ----------- | ----------- |

    - **가수부(mantissa):** 실수의 유효 자릿수들을 부호화된 고정 소수점으로 표현한 것
    - **지수부(exponent):** 실제 소수점의 위치를 지수 승으로 표현한 것

    

  - **단정도 실수의 가수 부분을 만드는 방법**

    - 정수부의 첫번째 자리가 1이 되도록 오른쪽으로 시프트
    - 소수점 이하를 23비트로 만든다.
    - 소수점 이하만을 가수 부분에 저장
    - 지수 부분은 시프트 한 자릿수만큼 증가 또는 감소

  - **단정도 실수의 지수 부분을 만드는 방법**

    - 지수부에는 8비트가 배정 (256개의 상태를 나타낼 수 있음)
    - 숫자로는 0 - 255까지 나타낼 수 있지만, 음수값을 나타낼 수 있어야 하므로 익세스 표현법을 사용
      - 익세스 표현법: 지수부의 값을 반으로 나누어 그 값을 0으로 간주하여 음수지수와 양수지수를 표현하는 방법



- 컴퓨터는 **실수를 근사적으로 표현**한다.
  - 이진법으로 표현할 수 없는 형태의 실수는 정확한 값이 아니라 근사값으로 저장되는데 이때 생기는 작은 오차가 계산 과정에서 다른 결과를 가져온다.
- **실수 자료형의 유효 자릿수**
  - 32비트 실수형 유효자릿수(십진수) : 6
  - 64비트 실수형 유효자릿수(십진수): 15



- 파이썬에서의 실수 표현 범위를 알아보자
  - 파이썬에서는 내부적으로 더 많은 비트를 사용해서 훨씬 넓은 범위의 실수를 표현할 수 있다.
  - 최대로 표현할 수 있는 값은 약 1.8 * 10^308이고 이 이상은 inf로 표현
  - 최소로 표현할 수 있는 값은 약  5.0 * 10^-324이며, 이 이하는 0으로 표현



## 재귀

```python
def f(i, N):
    if i == N:
        return
    else:
        B[i] = A[i]
        f(i+1, N)

N = 3
A = [10, 20, 30]
B = [0]*N
f(0,N)
print(B)
```

```python
def f1(arr, i):
	arr[i]  = 10
	
def f2(dic, key):
	dic[key] = 10
	
a =[1,2,3]	
f2(a, 0)
print(a)
```

```python
def f(i, N):
    if i == N:
        print(A)
    else:
        A[i] = 0
        f(i+1, N)
        A[i] = 1
        f(i+1, N)
    return

N = 3
A = [0]*N
f(0, N)
```



